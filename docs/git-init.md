## പേര് 
#### git-init - ഒരു ശൂന്യമായ Git ശേഖരം സൃഷ്ടിക്കുക അല്ലെങ്കിൽ നിലവിലുള്ള ഒരെണ്ണം വീണ്ടും ആരംഭിക്കുക

## സംഗ്രഹം
~~~
git init [-q | --quiet] [--bare] [--template=<template_directory>]
	  [--separate-git-dir <git dir>] [--object-format=<format>]
	  [-b <branch-name> | --initial-branch=<branch-name>]
	  [--shared[=<permissions>]] [directory]
~~~

	  
## വിവരണം

ഈ കമാൻഡ് ഒരു ശൂന്യമായ Git ശേഖരം സൃഷ്ടിക്കുന്നു - അടിസ്ഥാനപരമായി ഒബ്ജക്റ്റുകൾ, റഫുകൾ / ഹെഡ്സ്, റഫുകൾ / ടാഗുകൾ, ടെംപ്ലേറ്റ് ഫയലുകൾ എന്നിവയ്ക്കുള്ള ഉപഡയറക്ടറികളുള്ള ഒരു .git ഡയറക്ടറി. മാസ്റ്റർ ബ്രാഞ്ചിന്റെ HEAD പരാമർശിക്കുന്ന ഒരു പ്രാരംഭ HEAD ഫയലും സൃഷ്ടിക്കപ്പെടുന്നു. 
$GIT_DIR എൻ‌വയോൺ‌മെൻറ് വേരിയബിൾ‌ സജ്ജമാക്കിയിട്ടുണ്ടെങ്കിൽ‌, അത് റിപ്പോസിറ്ററിയുടെ അടിസ്ഥാനത്തിനായി ./.git എന്നതിനുപകരം ഉപയോഗിക്കാനുള്ള ഒരു പാത വ്യക്തമാക്കുന്നു.
$GIT_OBJECT_DIRECTORY എൻ‌വയോൺ‌മെൻറ് വേരിയബിൾ വഴി ഒബ്‌ജക്റ്റ് സ്റ്റോറേജ് ഡയറക്ടറി വ്യക്തമാക്കിയിട്ടുണ്ടെങ്കിൽ, ചുവടെ sha1 ഡയറക്ടറികൾ സൃഷ്ടിക്കപ്പെടുന്നു - അല്ലാത്തപക്ഷം സ്ഥിരസ്ഥിതി $ GIT_DIR / ഒബ്ജക്റ്റ് ഡയറക്ടറി ഉപയോഗിക്കുന്നു.

നിലവിലുള്ള ഒരു ശേഖരത്തിൽ git init പ്രവർത്തിപ്പിക്കുന്നത് സുരക്ഷിതമാണ്. ഇതിനകം ഉള്ള കാര്യങ്ങളെ ഇത് പുനരാലേഖനം ചെയ്യില്ല. പുതുതായി ചേർത്ത ടെം‌പ്ലേറ്റുകൾ എടുക്കുക എന്നതാണ് git init വീണ്ടും പ്രവർത്തിപ്പിക്കുന്നതിനുള്ള പ്രധാന കാരണം (അല്ലെങ്കിൽ - പ്രത്യേക git-dir നൽകിയിട്ടുണ്ടെങ്കിൽ ശേഖരം മറ്റൊരു സ്ഥലത്തേക്ക് മാറ്റുക).

## ഓപ്ഷനുകൾ
~~~
-q
--quiet 
അച്ചടി പിശകും മുന്നറിയിപ്പ് സന്ദേശങ്ങളും മാത്രം; മറ്റെല്ലാ output-കളും  അടിച്ചമർത്തപ്പെടും.
~~~
~~~
--bare 
നഗ്നമായ ഒരു ശേഖരം സൃഷ്ടിക്കുക. GIT_DIR എൻ‌വയോൺ‌മെന്റ് സജ്ജമാക്കിയിട്ടില്ലെങ്കിൽ, അത് നിലവിലുള്ള വർക്കിംഗ് ഡയറക്ടറിയിലേക്ക് സജ്ജമാക്കപ്പെടും.
~~~
~~~
--object-format=<format>
ശേഖരണത്തിനായി നൽകിയിരിക്കുന്ന ഒബ്‌ജക്റ്റ് ഫോർമാറ്റ് (ഹാഷ് അൽഗോരിതം) വ്യക്തമാക്കുക. സാധുവായ മൂല്യങ്ങൾ sha1 ഉം (പ്രവർത്തനക്ഷമമാക്കിയിട്ടുണ്ടെങ്കിൽ) sha256 ഉം ആണ്. sha1 ആണ് സ്ഥിരസ്ഥിതി.
~~~
~~~
--template=<template_directory> 
ടെംപ്ലേറ്റുകൾ ഉപയോഗിക്കുന്ന ഡയറക്ടറി വ്യക്തമാക്കുക. (ചുവടെയുള്ള "ടെം‌പ്ലേറ്റ് ഡയറക്ടറി" വിഭാഗം കാണുക.)
~~~
~~~
--separate-git-dir=<git dir> 
$ GIT_DIR അല്ലെങ്കിൽ ./.git/ എന്നതിലേക്ക് ഒരു ഡയറക്ടറിയായി റിപ്പോസിറ്ററി ആരംഭിക്കുന്നതിനുപകരം, യഥാർത്ഥ ശേഖരണത്തിലേക്കുള്ള പാത ഉൾക്കൊള്ളുന്ന ഒരു ടെക്സ്റ്റ് ഫയൽ സൃഷ്ടിക്കുക. ഈ ഫയൽ റിപ്പോസിറ്ററിയിലേക്കുള്ള ഫയൽസിസ്റ്റം-അജ്ഞ്ഞേയവാദി git പ്രതീകാത്മക ലിങ്കായി പ്രവർത്തിക്കുന്നു. ഇത് വീണ്ടും സമാരംഭിക്കുകയാണെങ്കിൽ, റിപ്പോസിറ്ററി നിർദ്ദിഷ്ട പാതയിലേക്ക് നീക്കും.
~~~

#### -b <branch-name
~~~
--initial-branch=<branch-name> 
പുതുതായി സൃഷ്ടിച്ച ശേഖരത്തിലെ പ്രാരംഭ ശാഖയ്ക്കായി നിർദ്ദിഷ്ട പേര് ഉപയോഗിക്കുക. വ്യക്തമാക്കിയിട്ടില്ലെങ്കിൽ, സ്ഥിരസ്ഥിതി നാമത്തിലേക്ക് മടങ്ങുക: master.
~~~
~~~ 
--shared[=(false|true|umask|group|all|world|everybody|0xxx)]
നിരവധി ഉപയോക്താക്കൾക്കിടയിൽ ജിറ്റ് ശേഖരം പങ്കിടേണ്ടതാണെന്ന് വ്യക്തമാക്കുക. ഒരേ ഗ്രൂപ്പിലെ ഉപയോക്താക്കളെ ആ ശേഖരത്തിലേക്ക് തള്ളിവിടാൻ ഇത് അനുവദിക്കുന്നു. വ്യക്തമാക്കുമ്പോൾ, "core.sharedRepository" എന്ന കോൺഫിഗറേഷൻ വേരിയബിൾ സജ്ജമാക്കിയിരിക്കുന്നതിനാൽ അഭ്യർത്ഥിച്ച അനുമതിയോടെ $ GIT_DIR ന് കീഴിലുള്ള ഫയലുകളും ഡയറക്ടറികളും സൃഷ്ടിക്കപ്പെടും. വ്യക്തമാക്കിയിട്ടില്ലെങ്കിൽ, umask (2) റിപ്പോർട്ടുചെയ്‌ത അനുമതികൾ Git ഉപയോഗിക്കും. ഓപ്ഷന് ഇനിപ്പറയുന്ന മൂല്യങ്ങൾ ഉണ്ടായിരിക്കാം, ഒരു മൂല്യവും നൽകിയിട്ടില്ലെങ്കിൽ ഗ്രൂപ്പിലേക്ക് സ്ഥിരസ്ഥിതിയാക്കും.
~~~
~~~
umask (or false)
Umask (2) റിപ്പോർട്ട് ചെയ്ത അനുമതികൾ ഉപയോഗിക്കുക. --Shared വ്യക്തമാക്കാത്തപ്പോൾ സ്ഥിരസ്ഥിതി.
~~~
~~~
group (or true) 
റിപ്പോസിറ്ററി ഗ്രൂപ്പ്-റൈറ്റബിൾ ആക്കുക, (കൂടാതെ g + sx, കാരണം git ഗ്രൂപ്പ് എല്ലാ ഉപയോക്താക്കളുടെയും പ്രാഥമിക ഗ്രൂപ്പായിരിക്കില്ല). സുരക്ഷിതമായ ഒരു ഉമാസ്ക് (2) മൂല്യത്തിന്റെ അനുമതികൾ അഴിക്കാൻ ഇത് ഉപയോഗിക്കുന്നു. മറ്റ് അനുമതി ബിറ്റുകൾക്കും umask ഇപ്പോഴും ബാധകമാണെന്ന കാര്യം ശ്രദ്ധിക്കുക (ഉദാ. Umask 0022 ആണെങ്കിൽ, ഗ്രൂപ്പ് ഉപയോഗിക്കുന്നത് മറ്റ് (ഗ്രൂപ്പ് ഇതര) ഉപയോക്താക്കളിൽ നിന്ന് വായനാ ആനുകൂല്യങ്ങൾ നീക്കംചെയ്യില്ല). റിപ്പോസിറ്ററി അനുമതികൾ കൃത്യമായി എങ്ങനെ വ്യക്തമാക്കാം എന്നതിന് 0xxx കാണുക.
~~~
~~~
all (or world or everybody)
ഗ്രൂപ്പിനെപ്പോലെ തന്നെ, പക്ഷേ എല്ലാ ഉപയോക്താക്കൾക്കും ശേഖരം വായിക്കാൻ കഴിയുന്നതാക്കുക.
~~~
~~~
0xxx
0xxx ഒരു ഒക്ടൽ നമ്പറാണ്, ഓരോ ഫയലിനും 0xxx മോഡ് ഉണ്ടാകും. 0xxx ഉപയോക്താക്കളുടെ umask (2) മൂല്യത്തെ അസാധുവാക്കും (മാത്രമല്ല ഗ്രൂപ്പായി അനുമതികൾ അഴിച്ചുമാറ്റുക മാത്രമല്ല എല്ലാം). 0640 ഗ്രൂപ്പ് വായിക്കാൻ കഴിയുന്നതും എന്നാൽ ഗ്രൂപ്പ് എഴുതാൻ കഴിയാത്തതോ മറ്റുള്ളവർക്ക് ആക്സസ് ചെയ്യാവുന്നതോ ആയ ഒരു ശേഖരം സൃഷ്ടിക്കും. 0660 നിലവിലെ ഉപയോക്താവിനും ഗ്രൂപ്പിനും വായിക്കാനും വായിക്കാനും കഴിയുന്നതും എന്നാൽ മറ്റുള്ളവർക്ക് പ്രവേശിക്കാൻ കഴിയാത്തതുമായ ഒരു റിപ്പോ സൃഷ്ടിക്കും.
സ്ഥിരസ്ഥിതിയായി, കോൺഫിഗറേഷൻ flag shared.denyNonFastForwards പങ്കിട്ട ശേഖരണങ്ങളിൽ പ്രാപ്തമാക്കിയിരിക്കുന്നതിനാൽ അതിലേക്ക് വേഗത്തിൽ കൈമാറാത്ത ഒരു പുഷ് നിങ്ങൾക്ക് നിർബന്ധിക്കാൻ കഴിയില്ല.
~~~
നിങ്ങൾ ഒരു ഡയറക്ടറി നൽകുകയാണെങ്കിൽ, കമാൻഡ് അതിനുള്ളിൽ പ്രവർത്തിക്കുന്നു. ഈ ഡയറക്ടറി നിലവിലില്ലെങ്കിൽ, അത് സൃഷ്ടിക്കപ്പെടും.

## ടെംപ്ലേറ്റ് ഡയറക്ടറി

ഒരു ഡോട്ട് ഉപയോഗിച്ച് ആരംഭിക്കാത്ത ടെംപ്ലേറ്റ് ഡയറക്ടറിയിലെ ഫയലുകളും ഡയറക്ടറികളും സൃഷ്ടിച്ചതിനുശേഷം $ GIT_DIR ലേക്ക് പകർത്തപ്പെടും.

ടെംപ്ലേറ്റ് ഡയറക്ടറി ഇനിപ്പറയുന്നതിൽ ഒന്നായിരിക്കും (ക്രമത്തിൽ):

* --template ഓപ്ഷനിൽ നൽകിയിരിക്കുന്ന ആർഗ്യുമെന്റ്;

* $ GIT_TEMPLATE_DIR എൻ‌വയോൺ‌മെൻറ് വേരിയബിളിലെ ഉള്ളടക്കങ്ങൾ‌;

* init.templateDir കോൺഫിഗറേഷൻ വേരിയബിൾ; അഥവാ

* സ്ഥിരസ്ഥിതി ടെംപ്ലേറ്റ് ഡയറക്ടറി: / usr / share / git-core / templates.

സ്ഥിരസ്ഥിതി ടെംപ്ലേറ്റ് ഡയറക്ടറിയിൽ ചില ഡയറക്ടറി ഘടന ഉൾപ്പെടുന്നു, "പാറ്റേണുകൾ ഒഴിവാക്കുക" (ജിറ്റിഗ്നോർ കാണുക), സാമ്പിൾ ഹുക്ക് ഫയലുകൾ എന്നിവ നിർദ്ദേശിക്കുന്നു.

സാമ്പിൾ ഹുക്കുകൾ എല്ലാം സ്ഥിരസ്ഥിതിയായി അപ്രാപ്തമാക്കി. സാമ്പിൾ ഹുക്കുകളിലൊന്ന് പ്രവർത്തനക്ഷമമാക്കുന്നതിന് അതിന്റെ .സാമ്പിൾ സഫിക്‌സ് നീക്കംചെയ്‌ത് അതിന്റെ പേരുമാറ്റുക.

നിങ്ങൾ ഒരു ഡയറക്ടറി നൽകുകയാണെങ്കിൽ, കമാൻഡ് അതിനുള്ളിൽ പ്രവർത്തിക്കുന്നു. ഈ ഡയറക്ടറി നിലവിലില്ലെങ്കിൽ, അത് സൃഷ്ടിക്കപ്പെടും.

ഉദാഹരണങ്ങൾ

നിലവിലുള്ള കോഡ് ബേസിനായി ഒരു പുതിയ ജിറ്റ് ശേഖരം ആരംഭിക്കുക.
~~~
$ cd /path/to/my/codebase
$ git init      (1)
$ git add .     (2)
$ git commit    (3)
~~~

* ഒരു /path/to/my/codebase/.git ഡയറക്ടറി സൃഷ്ടിക്കുക.

* നിലവിലുള്ള എല്ലാ ഫയലുകളും സൂചികയിലേക്ക് ചേർക്കുക.

* ചരിത്രത്തിലെ ആദ്യത്തെ പ്രതിബദ്ധതയായി പ്രാകൃത അവസ്ഥയെ രേഖപ്പെടുത്തുക.

